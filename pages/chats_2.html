<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />
	<meta name="keywords" content="D3,codeSmells,design">
	<meta name="author" content="Sai Krishna">

	<meta http-equiv="Content-Type" content="text/html">
	<title>Chats/K_ and I</title>

	<link rel="stylesheet" type="text/css" media="all" href="../css/styles.css">

</head>

<body>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
	<script src="../scripts/tree.js"></script>
	<script src="../scripts/array.js"></script>
	<script>
		document.addEventListener("DOMContentLoaded", function (event) {
			drawArray("array1", ['a', 'b', 'b', 'c', 'c', 'b', 'a'], ["i", "j"], [0, 6]);
		});

		document.addEventListener("DOMContentLoaded", function (event) {
			drawArray("array2", ['x', 'x', 'b', 'c', 'c', 'x', 'x'], ["i", "j"], [2, 4]);
		});

		document.addEventListener("DOMContentLoaded", function (event) {
			drawArray("array3", ['x', 'x', 'x', 'c', 'c', 'x', 'x'], ["i", "j"], [3, 4]);
		});

		document.addEventListener("DOMContentLoaded", function (event) {
			drawArray("array4", ['x', 'x', 'b', 'c', 'x', 'x', 'x'], ["i", "j"], [2, 3]);
		});

		document.addEventListener("DOMContentLoaded", function (event) {
			drawArray("array5", ['9', '5', '4', '3', '1', '2'], ["n", "i"], [6, 4]);
		});
	</script>

	<h1>K_ and I</h1>
	<h2><a href="../index.html" style="color:#69c">Home</a></h2>

	<div class="container">
		<p class="datestamp">July 26, 2016, 12:05 PM</p>

		<div class="bubble">
			<p><b>K_</b><br />
				Hi!</p>
		</div>

		<div class="bubble bubble-alt yellow">
			<p><b>I</b><br />
				You should complete 2 coding questions. <br />
				You should finish both in 20 min each.<br />
				I expect you to come up with almost executable code with test cases.</p>
		</div>


		<div class="bubble">
			<p><b>K_</b><br />
				Oh! ok sure.</p>
			<div class="bubble bubble-alt red">
				<p><b>Mind whisper</b><br />What! This is insane.
			</div>
		</div>

		<div class="bubble bubble-alt yellow">
			<p><b>I</b><br />
				Given a string tell if it is a palindrome or not after deleting any one character in it.</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				Ok.</p>
			<div class="bubble bubble-alt red">
				<p><b>Mind whisper</b><br />Lets start with palindrome code and see what happens<br /></p>
			</div>
			<div class="bubble">
				<p><b>Writes code</b><br />
				<pre><code>
boolean validPalindrome(String s) {
	while (i < j) {
		if (s.charAt(i) == s.charAt(j))	{i++; j--; continue;}
		
		// Not match case



	}
	return true;
}
	   </code></pre>
				</p>
			</div>
			<svg id="array1" xmlns="http://www.w3.org/2000/svg" />

			<div class="bubble bubble-alt red">
				<p><b>Mind whisper</b><br />
					- When not matched what should do?<br />
					- Cannot proceed? <br />
					- So, should I delete one of them.<br />
					- Skipping i means deleting the element. But if I skip i and it turns out not palindrome how will I
					go back<br />
					- It becomes O(n^2)<br />
					- Save the i and j and come back if fails.
			</div>
			</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				- Skipping i means deleting the element here. But, if I skip i or j and it turns out not palindrome how
				will I go back?<br />
				- It becomes O(n^2)<br />
				- I will save the decisions in skipped_i and skipped_j.<br />
				- Or I can check deleting one element and see if it is a palindrome, which is a brute force method
				taking O(n^2) time</p>
		</div>

		<div class="bubble bubble-alt yellow">
			<p><b>I</b><br />
				I like the i,j two pointer approach. Can you proceeed in that direction.</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				Will try skipping i. We just need to check for full palindrome. <br />
				Then do for j. <br />
				One of them should be a palindrome for a valid input<sup>*</sup>.
			<div class="bubble">
				<p><b>Writes code</b><br />
				<pre><code>
boolean validPalindrome(String s) {
	int i = 0, j = s.length() - 1;
	while (i < j) {
		if (s.charAt(s) != s.charAt(e)) {
			return isPalindrome(s, i + 1, j) || 
			       isPalindrome(s, i, j - 1);
		}
		i++; j--;
	}
	return true;
}

boolean isPalindrome(String s, int i, int j) {
	while (i < j) {
		if (s.charAt(i) != s.charAt(j)){
			return false;
		}
		i++; j--;
	}
	return true;
}
	   </code></pre>
				</p>
			</div>
			</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				<svg id="array2" xmlns="http://www.w3.org/2000/svg" />
				First check palindrome for (3.4).<br />
				<svg id="array3" xmlns="http://www.w3.org/2000/svg" />
				On (3.4) will give true.<br />
				Then check palindrome for (2,3).<br />
				On (3.4) will give false.<br />
				<svg id="array4" xmlns="http://www.w3.org/2000/svg" />
				But we need not call the second one if first return true so use "||"<br />
				We take O(n) time and O(1) space
			</p>
		</div>

		<div class="bubble bubble-alt yellow">
			<p><b>I</b><br />
				Nice. Let's proceeed to the next question</p>
		</div>

		<div class="bubble bubble-alt yellow">
			<p><b>I</b><br />
				You are given a number. You can rearrange any number of digits. Return the next bigger number you can
				make with the number.<br />
				Example: 954312 gives 954321</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				Oh! ok sure.</p>
			<div class="bubble">
				<p><b>Mind whisper</b><br />Only 10 mins. This is gone.
			</div>
		</div>


		<div class="bubble">
			<p><b>K_</b><br />
				Ok, 0's can be a problem</p>


			<div class="bubble">
				<p><b>Writes code</b><br />
				<pre><code>
int nextGreaterElement(int num) {
	int[] digits = getDigits(num);
	int n = digits.length;
	int i = n - 2;
	
	// Find the first decreasing element from the end
	while (i >= 0 && digits[i] >= digits[i + 1]) {
		i--;
	}
	
	// Need not proceed, but make the next number with i to n-1 range
	if(i==0) return -1;
	
	return arrayToInt(digits);
}
		</code></pre>
				</p>
			</div>

			<svg id="array5" xmlns="http://www.w3.org/2000/svg" />

			<div class="bubble">
				<p><b>Mind whisper</b><br />
					The next number is the numbers in the reverse order.<sup>**<sup>
			</div>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				The next number is the numbers in the reverse order from i. 12 becomes 21 reverse(nums, i + 1,
				n-1).<br />
				But not all the time, this is making the number much bigger.</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				Ok, 0's can be a problem. But we are finding frist smaller element as i so it will not matter.</p>
			Find the rightmost element that is greater than nums[i] swap and then reverse.</p>
			<div class="bubble">
				<p><b>Writes code</b><br />
				<pre><code>
int nextGreaterElement(int num) {
	int[] digits = getDigits(num);
	int n = digits.length;
	if(n < 2) return - 1;
	int i = n - 2;
	
	// Find the first decreasing element from the end
	while (i >= 0 && digits[i] >= digits[i + 1]) {
		i--;
	}

	if(i===-1) return -1;

	return next(digits, i, n-1);
}

int next(digits, int i, int e) {
		while (digits[e] <= digits[i]) {
			e--;
		}

		// Swap elements at i and j
		int t = digits[i];
		digits[i] = digits[j];
		digits[j] = t;
	}
	
	// Reverse the elements from i+1 to the end of the array
	reverse(nums, i + 1, e);
}
		</code></pre>
				</p>
			</div>

			<svg id="array5" xmlns="http://www.w3.org/2000/svg" />

			<div class="bubble">
				<p><b>Mind whisper</b><br />Already over time!
			</div>
		</div>

		<div class="bubble bubble-alt yellow">
			<p><b>I</b><br />
				Nice. What is the complexity</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				O(n) both space and time.</p>
		</div>

		<div class="bubble bubble-alt yellow">
			<p><b>I</b><br />
				We are a bit over time ... Bye.</p>
		</div>

		<div class="bubble bubble-alt red">
			<p><b>M</b><br />
				Thanks for applying .., other ...</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				<b>Reflections</b><br />
				Actually, this is not how it went I modified it to add value as working solutions for you as readers to
				take away.<br /><br />

				It would be great if I had got the idea of doing the "or" check in question 1. I struggled to move pass
				the skip i point in solving the problem and wasted most of my time.<br /><br />

				And in question 2 as there was no time to code in time stress. I missed to observe the reversing of
				number in the tail part. Instead I told I will use a min heap and max heap which could work, but it will
				use extra space. Reverse could be done in place.<br /><br />

				Finally not to worry you but, I have to say I used GitHub Copilot in Visual Studio Code for the first
				time and it wrote the answer in seconds for both questions even with html paged in the context to
				confuse its next word prediction!! It is really awesome and atleast it helped me quickly realize my
				mistakes.
			</p>
		</div>

		<div class="bubble">
			<p><b>K_</b><br />
				<b>You reached the end of this conversation.</b><br />
				These are "my personal" pages. Please contact me for any questions or suggestions. Thank you.
			</p>
		</div>
	</div><!-- @end .container -->
</body>

</html>